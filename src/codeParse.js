var fs = require('fs');
var path = require('path');
var _ = require('lodash');

var Util = require('./util');
var FileOperation = require('./fileOperation');
var Police = require('./police');

var CodeParse = {
    initCode: function () {
        return (
            `{
  "name": "New Step",
  "description": "A new step you just created",
  "invoke": "",
  "inputlists": [
    
    ],
  "options": [
    
    ],
  "input_option": "",
  "output_option": "",
  "output_files": [
    
    ]
}`);
  },

  syncEditorToState: function(app) {
    var tool = Util.filterByProperty(app.state.tools, "id", app.state.currentTool);
    var codeobj = {};
    try{
      codeobj = JSON.parse(tool.code);
    }catch(e){
      console.log('JSON not valid.');
      tool.valid = false;
      app.setState(app.state);
      return;
    }
    tool.valid = true;
    tool.codeobj = codeobj;
    tool.name = codeobj.name;
    tool.description = codeobj.description;
    app.setState(app.state);
  },

  syncStateToEditor: function(app) {
    var tool = Util.filterByProperty(app.state.tools, "id", app.state.currentTool);
    tool.code = JSON.stringify(tool.codeobj, null, "  ");
  },
  
  generateCommand: function(app) { //combine each tool's command to generate a pipeline
    //parse every tool
    var originalTool = app.state.currentTool;
    for (var i = 0; i <= app.state.lastId; i++){
      app.state.currentTool=i;
      if(!Police.checkToolDefinition(app)){
        return false;
      }
      this.parseToolCommand(app);
      FileOperation.newParse(app);
    }
    app.state.currentTool = originalTool;
    
    app.state.command = "#!/usr/bin/bash";
    app.state.command += "\n#This code is generated by PipelineDog.\n"
    app.state.command += "cd "+app.state.workDir+"\n";
    app.state.tools.map(function(level, i) {
      level.map(function(tool, i) {
        app.state.command += "\n"+tool.parsedCommand;
      }, this)
      app.state.command += "\nwait\n";
    })
    
    return true;
  },
  
  parseToolCommand: function(app) { //replace placeholders and generate command for each tool
    
    //if these symbols are changed, the police class need to change accordingly.
    var scope = /[\{\}]/;
    var segment = '|';

    var tool = Util.filterByProperty(app.state.tools, "id", app.state.currentTool);
    
    this.convertExpressions(app, scope, segment);
    if(!tool.looping) { //if the tool is not looping     
      
      tool.parsedOptions = tool.codeobj.options.map(function(s, index) { //replace placeholders with the translated expressions
        var a = s.split(scope);
        for (var i=1; i < a.length-1; i+=2) {
          for (var j=0; j < tool.options.length; j++) {
            if(a[i] == tool.options[j]){
              a[i] = tool.expressions[j];
            }
          }
        }
        return a.join('');
      }, this);
      tool.parsedCommand = tool.codeobj.invoke + " " + tool.parsedOptions.join(" ") + "&"; 
       
    } else { //if the tool is looping
      
      tool.parsedCommand = "";
      
      var loopArray = [];
      for (var i=0; i < tool.options.length; i++) {
        if(tool.expressions[i]) loopArray.push(tool.expressions[i].split('^LOOP^'));
      }
      
      loopArray[0].map(function(fn, index, array) {
        tool.parsedOptions = tool.codeobj.options.map(function(s, innerindex) { //replace placeholders with the translated expressions
          var a = s.split(scope);
          for (var i=1; i < a.length-1; i+=2) {
            for (var j=0; j < tool.options.length; j++) {
              if(a[i] == tool.options[j]){
                a[i] = loopArray[j][index];
              }
            }
          }
          return a.join('');
        }, this);
        
        if(index!==array.length-1) {
          tool.parsedCommand += tool.codeobj.invoke + " " + tool.parsedOptions.join(" ") + "&\n";
        } else {
          tool.parsedCommand += tool.codeobj.invoke + " " + tool.parsedOptions.join(" ") + "&";
        }
        
        //process looping for output files
        if(tool.expressions[tool.expressions.length-1]) {
          tool.expressions[tool.expressions.length-1] = tool.expressions[tool.expressions.length-1].map(function(of, i) {
            if(of.indexOf('^LOOP^') == -1) {
              return of;
            } else {
              return of.split('^LOOP^');
            }
          }, this)
          tool.output_files = _.flattenDeep(tool.expressions[tool.expressions.length-1]);   
        }
        
      }, this);     
    }
    
  },
  
  convertExpressions: function(app, scope, segment) { //recognize LEASH expressions, also update output_files info
    var tool = Util.filterByProperty(app.state.tools, "id", app.state.currentTool);
    tool.expressions = [];
    tool.options = [];
    
    for (var key in tool.codeobj) {
      if(key.slice(-7) == '_option') {
        tool.expressions.push(tool.codeobj[key]);
        tool.options.push(key.slice(0, -7).toUpperCase());
      }
    }
    tool.expressions.push(tool.codeobj.output_files);
    
    tool.expressions = tool.expressions.map(function(e, i, a) { //convert objects to standard LEASH
      if(typeof(e) == "object") { //Long(object) format
        var pseudoString = "{";
        if(e.file) pseudoString += `${e.file}F|`;
        if(e.line) pseudoString += `${e.line}L|`;
        if(e.base) pseudoString += `${e.base}B|`;
        if(e.extension) pseudoString += `${e.extension}E|`;
        if(e.arrangement) pseudoString += `${e.arrangement}A|`;
        pseudoString = pseudoString.slice(0,-1);
        pseudoString += "}";
        return i!=a.length-1?pseudoString:[pseudoString];
      }
      else { //Short(string or array) format
        return e;
      }    
    }.bind(this));

    for (var j=0; j < tool.expressions.length-1; j++){ //translate each LEASH expressions
      if(tool.expressions[j] && typeof(tool.expressions[j]) != "object") {
        var a = tool.expressions[j].split(scope);
        for (var i=1; i < a.length-1; i+=2) {
          a[i] = this.parseLEASH(a[i], tool, segment);
        }
        tool.expressions[j] = a.join("");
      }
    }
    
    var outfilesArray = []; //process output_files array
    tool.expressions[tool.expressions.length-1].map(function(s) {
      var a = s.split(scope);
      if(a.length>=3){
        for (var i=1; i < a.length-1; i+=2) {
          outfilesArray.push(this.parseLEASH(a[i], tool, segment));
        }
      } else {
        outfilesArray.push(s);
      }
    }.bind(this));
    tool.expressions[tool.expressions.length-1] = _.flattenDeep(outfilesArray);
    
  },
  
  parseLEASH: function(expression, tool, segment) { //parse LEASH expression and process inputlists
    var inputlists = tool.codeobj.inputlists;
    var segs = [];
    var f = [], l = [], b = [], e = [], a = "";
    
    expression.split(segment).map(function(s, i) {
      if(s.slice(-1) == 'F') {
        segs[0] = s;
      }
      if(s.slice(-1) == 'L') {
        segs[1] = s;
      }
      if(s.slice(-1) == 'B') {
        segs[2] = s;
      }
      if(s.slice(-1) == 'E') {
        segs[3] = s;
      }
      if(s.slice(-1) == 'A') {
        segs[4] = s;
      }
    });
    if(!segs[0]) {
      segs[0] = "-F";
    }
    if(!segs[1]) {
      segs[1] = "-L";
    }
    if(!segs[2]) {
      segs[2] = "P-B";
    }
    if(!segs[3]) {
      segs[3] = "''E";
    }
    if(!segs[4]) {
      segs[4] = "'n'A";
    }
    
    segs.map(function(s, i) {
      switch(s.slice(-1)) {
        
        case 'F':
          var inputlistArray = this.parseRange(s.slice(0,-1), inputlists.length, inputlists); 
          inputlistArray.map(function(fl, i) {
            fs.readFileSync(inputlists[fl-1], 'utf8').split('\n').map(function(fline) {
              f.push(fline);
            }, this);
          }, this);
        break;
          
        case 'L':
          var lineArray = this.parseRange(s.slice(0,-1), f.length, f);
          lineArray.map(function(line, i) {
            l.push(f[line-1]);
          }, this);
        break;
          
        case 'B':
          b = l.map(function(filename, i) {
            var name = [];
            var baseArray = [];
            var dirname = path.dirname(filename);
            var basename = path.basename(filename);
            var bases = basename.split('.');
            
            if(s.slice(0, 1) == 'P'){
              baseArray = this.parseRange(s.slice(1,-1), bases.length, bases);
            } else {
              baseArray = this.parseRange(s.slice(0,-1), bases.length, bases);
            }
            baseArray.map(function(base, i) {
              name.push(bases[base-1]);
            }, this);
            return s.slice(0, 1) == 'P' ? path.join(dirname, name.join('.')) : name.join('.');
          }, this);
        break;
          
        case 'E':
          var r = '';
          e = b.map(function(filename, i) {
            var arr = s.slice(0,-1).split("'");
            for (var i=0; i < arr.length-1; i+=2) {
              var extensionString = arr[i+1];
              if(arr[i] == 'PRE') {
                var basen = path.basename(filename);
                var dirn = path.dirname(filename);
                if(dirn == ".") {
                  filename = extensionString + basen;
                } else {
                  filename = dirn + "/" + extensionString + basen;
                }
              } else {
                filename = filename + extensionString;
              }
            }
     
            return filename;     
          });
        break;
          
        case 'A':
          var arrangeString = s.replace(/['"]+/g, '').slice(0,-1);
          if(arrangeString == 'c') {
            a = e.join(',');
          } else if(arrangeString == 's') {
            a = e.join(' ');
          } else if(arrangeString == 'a') {
            a = e;
          } else if(arrangeString == 'n') {
            a = e.join('');
          } else if(arrangeString == 'l') {
            tool.looping = true;
            a = e.join('^LOOP^');
          } else {
            a = e.map(function(filename, i){
              return arrangeString+' '+filename;
            }).join(' ');
          }
        break;
 
      }
    }, this);
    return a;
  },
  
  parseRange: function(s, length, arr) {
    var r = [];    
    if(s.indexOf('/') > -1) {
      //parse regex range
      var regex = new RegExp(s.slice(1,-1));
      arr.map(function(string, i) {
        if(string.search(regex) > -1) {
          r.push(i+1);
        };
      }, this);
      return r;
    } else {
      //parse numeric range
      var a = s.split(',');
      a.map(function(ss, i) {
        if(ss.indexOf('-') > -1) {
          b = ss.split('-');
          if(b[0]=="" && b[1]==""){b[0] = 1; b[1] = length;}
          else if(b[1]==""){b[1] = length;}
          else if(b[0]==""){b[0] = 1;}
          else if(b.length>2 || Number(b[0]) > Number(b[1])){
            console.log("illegal range.")
            return;
          }
          for (var i = Number(b[0]); i <= Number(b[1]); i++) {
            r.push(i);
          }
        } else {
          r.push(Number(ss));
        }
      }, this);
      r.sort(function(x,y){return x-y});
      return _.uniq(r);
    }
  },

};

module.exports = CodeParse;
