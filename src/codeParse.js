var fs = require('fs');
var Util = require('./util');
var _ = require('lodash');

var CodeParse = {
    initCode: function () {
        return (
            `{
  "name": "New Step",
  "description": "A new step you just created",
  "invoke": "",
  "filelists": [],
  "options": [],
  "input_option": "",
  "output_option": "",
  "label_option": "",
  "output_files": ""
}`);
  },

  syncEditorToState: function(app) {
    var tool = Util.filterByProperty(app.state.tools, "id", app.state.currentTool);
    var codeobj = {};
    try{
      codeobj = JSON.parse(tool.code);
    }catch(e){
      console.log('JSON not valid.');
      tool.valid = false;
      app.setState(app.state);
      return;
    }
    tool.valid = true;
    tool.codeobj = codeobj;
    tool.name = codeobj.name;
    tool.description = codeobj.description;
    app.setState(app.state);
  },

  syncStateToEditor: function(app) {
    var tool = Util.filterByProperty(app.state.tools, "id", app.state.currentTool);
    var codeobj = {};
    try{
      codeobj = JSON.parse(tool.code);
    }catch(e){
      console.log('JSON not valid.');
      return;
    }
    codeobj.name = tool.name;
    codeobj.description = tool.description;
    tool.codeobj = codeobj;
    tool.code = JSON.stringify(codeobj, null, "  ");
  },
  
  generateCommnad: function(app) { //combine each tool's command to generate a pipeline
    var command = "#!/usr/bin/bash";
    command += "\n#This code is generated by PipelineDog."
    app.tools.map(function(hierarchy, i) {
      hierarchy.map(function(tool, i) {
        command += "\n"+tool.parsedCommand+"&";
      }.this)
      command += "\nwait";
    })
  },
  
  parseToolCommand: function(app) { //generate command for each tool
    var tool = Util.filterByProperty(app.state.tools, "id", app.state.currentTool);
    tool.parsedCommand = tool.codeobj.invoke + tool.codeobj.options.join(" ");
  },
  
  convertOptionString: function(app) { //recognize LEASE expression and replace it
    var codeobj = Util.filterByProperty(app.state.tools, "id", app.state.currentTool).codeobj;
    var scope = '%';
    var segment = ':';
    var strings = [codeobj.input_option];//, codeobj.output_option, codeobj.label_option, codeobj.output_files];
    strings.map(function(s, i) {
      if(s == undefined) {return;}
      var a = s.split(scope);
      for (var i=1; i<a.length-1; i+=2) {
        a[i] = this.parseLEASE(a[i], codeobj, segment);
      }
      r = a.join("");
    },this);
    
  },
  
  parseLEASE: function(expression, codeobj, segment, app) { //parse LEASE expression and process filelists
    var filelists = codeobj.filelists;
    var segs = expression.split(segment);
    var filelines = [];
    var f = [], l = [], b = [], e = [], a = "";
    
    segs.map(function(s, i) {
      switch(s.slice(-1)) {
          
        case 'F':
          var filelistArray = this.parseRange(s.slice(0,-1), filelists.length); 
          filelistArray.map(function(fl, i) {
            f.push(this.readFileList(filelists[fl-1]));
          },this);
        break;
          
        case 'L':
          var lineArray = this.parseRange(s.slice(0,-1), f.length);
          lineArray.map(function(line, i) {
            l.push(f[line-1]);
          }, this);
        break;
          
        case 'B':
          b = l.map(function(filename, i) {
            var name = [];
            var bases = filename.split('.');
            var baseArray = this.parseRange(s.slice(0,-1), bases.length);
            baseArray.map(function(base, i) {
              name.push(bases[base-1]);
            }, this);
            return name.join('.');
          });
        break;
          
        case 'E':
          e = b.map(function(filename, i) {
            var extensionString = s.replace(/['"]+/g, '').slice(0,-1);
            if(extensionString.substr(0,1) == '-') {
              return extensionString.slice(1) + filename;
            } else {
              return filename + extensionString;
            }
          });
        break;
          
        case 'A':
          var arrangeString = s.replace(/['"]+/g, '').slice(0,-1);
          if(arrangeString == 'c') {
            a = e.join(',');
          } else if(arrangeString == 's') {
            a = e.join(' ');
          } else if(arrangeString == 'l') {
            codeobj.looping = true;
            a = e;
          } else {
            a = e.map(function(filename, i){
              return arrangeString+' '+filename;
            }).join(' ');
          }
        break;
          
        default:
          console.log("illegal LEASE expression.")
      }
    }, this);
    
    return a === "" ? e : a;
  },
  
  parseRange: function(s, length) {
    var a = s.split(',');
    var r = [];
    a.map(function(ss, i) {
      if(ss.indexOf('-') > -1) {
        b = ss.split('-');
        if(b[0]=="" && b[1]==""){b[0] = 1; b[1] = length;}
        else if(b[1]==""){b[1] = length;}
        else if(b[0]==""){b[0] = 1;}
        else if(b.length>2 || Number(b[0]) > Number(b[1])){
          console.log("illegal range.")
          return;
        }
        for (var i = Number(b[0]); i <= Number(b[1]); i++) {
          r.push(i);
        }
      } else {
        r.push(Number(ss));
      }
    }, this);
    r.sort(function(x,y){return x-y});
    return _.uniq(r);
  },
  
  readFilelist: function(f) {
    return fs.readFileSync(f).split('\n');
  },

};

module.exports = CodeParse;
