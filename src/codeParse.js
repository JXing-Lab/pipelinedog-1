var fs = require('fs');
var path = require('path');
var _ = require('lodash');

var Util = require('./util');


var CodeParse = {
    initCode: function () {
        return (
            `{
  "name": "New Step",
  "description": "A new step you just created",
  "invoke": "",
  "inputlists": [
    
  ],
  "options": [
    
  ],
  "input_option": "",
  "output_option": "",
  "label_option": "",
  "output_files": [

  ]
}`);
  },

  syncEditorToState: function(app) {
    var tool = Util.filterByProperty(app.state.tools, "id", app.state.currentTool);
    var codeobj = {};
    try{
      codeobj = JSON.parse(tool.code);
    }catch(e){
      console.log('JSON not valid.');
      tool.valid = false;
      app.setState(app.state);
      return;
    }
    tool.valid = true;
    tool.codeobj = codeobj;
    tool.name = codeobj.name;
    tool.description = codeobj.description;
    app.setState(app.state);
  },

  syncStateToEditor: function(app) {
    var tool = Util.filterByProperty(app.state.tools, "id", app.state.currentTool);
    tool.code = JSON.stringify(tool.codeobj, null, "  ");
  },
  
  generateCommand: function(app) { //combine each tool's command to generate a pipeline
    app.state.command = "#!/usr/bin/bash";
    app.state.command += "\n#This code is generated by PipelineDog.\n"
    app.state.tools.map(function(level, i) {
      level.map(function(tool, i) {
        app.state.command += "\n"+tool.parsedCommand;
      }, this)
      app.state.command += "\nwait";
    })
  },
  
  parseToolCommand: function(app) { //replace placeholders and generate command for each tool
    
    var scope = /[\{\}]/;
    var segment = '|';
    
    var tool = Util.filterByProperty(app.state.tools, "id", app.state.currentTool);
    this.convertExpressions(app, scope, segment);
    if(!tool.looping) { //if the tool is not looping     
      tool.parsedOptions = tool.codeobj.options.map(function(s, i) { //replace placeholders with the translated expressions
        var a = s.split(scope);
        for (var i=1; i < a.length-1; i+=2) {
          if(a[i] == "INPUT"){
            a[i] = tool.expressions[0];
          }
          if(a[i] == "OUTPUT"){
            a[i] = tool.expressions[1];
          }
          if(a[i] == "LABEL"){
            a[i] = tool.expressions[2];
          }
        }
        return a.join('');
      }, this);
      tool.parsedCommand = tool.codeobj.invoke + " " + tool.parsedOptions.join(" ") + "&";  
    } else { //if the tool is looping  
      tool.parsedCommand = "";
      var inputLoopArray = [], outputLoopArray = [], labelLoopArray = [];
      if(tool.expressions[0]) inputLoopArray = tool.expressions[0].split('^LOOP^');
      if(tool.expressions[1]) outputLoopArray = tool.expressions[1].split('^LOOP^');
      if(tool.expressions[2]) labelLoopArray = tool.expressions[2].split('^LOOP^');    
      inputLoopArray.map(function(fn, i, a) {
        var index = i;
        var filename = fn;
        var array = a;
        tool.parsedOptions = tool.codeobj.options.map(function(s, i) { //overwrite the placeholder replacement to assign one filename to parsed options a time
          var a = s.split(scope);
          for (var i=1; i < a.length-1; i+=2) {
            if(a[i] == "INPUT"){
              a[i] = inputLoopArray[index];
            }
            if(a[i] == "OUTPUT"){
              a[i] = outputLoopArray[index];
            }
            if(a[i] == "LABEL"){
              a[i] = labelLoopArray[index];
            }
          }
          return a.join('');
        }, this);
        if(index!==array.length-1) {
          tool.parsedCommand += tool.codeobj.invoke + " " + tool.parsedOptions.join(" ") + "&\n";
        } else {
          tool.parsedCommand += tool.codeobj.invoke + " " + tool.parsedOptions.join(" ") + "&";
        }
      }, this);     
    }
    
  },
  
  convertExpressions: function(app, scope, segment) { //recognize LEASH expressions, also update output_files info
    var tool = Util.filterByProperty(app.state.tools, "id", app.state.currentTool);
    tool.expressions = [tool.codeobj.input_option, tool.codeobj.output_option, tool.codeobj.label_option];
    
    tool.expressions = tool.expressions.map(function(s, i) { //translate each LEASH expressions
      if(!s) {return;}
      var a = s.split(scope);
      for (var i=1; i < a.length-1; i+=2) {
        a[i] = this.parseLEASH(a[i], tool, segment, fs, this.parseRange);
      }
      return a.join("");
    }, this);
    
    var outfilesArray = []; //process output_files array
    tool.codeobj.output_files.map(function(s) {
      var a = s.split(scope);
      if(a.length>=3){
        for (var i=1; i < a.length-1; i+=2) {
          outfilesArray.push(this.parseLEASH(a[i], tool, segment, fs, this.parseRange));
        }
      } else {
        outfilesArray.push(s);
      }
    }, this);     
    tool.output_files = _.flattenDeep(outfilesArray);
    
  },
  
  parseLEASH: function(expression, tool, segment, fs, parseRange) { //parse LEASH expression and process inputlists
    var inputlists = tool.codeobj.inputlists;
    var segs = [];
    var f = [], l = [], b = [], e = [], a = "";
    
    expression.split(segment).map(function(s, i) {
      if(s.slice(-1) == 'F') {
        segs[0] = s;
      }
      if(s.slice(-1) == 'L') {
        segs[1] = s;
      }
      if(s.slice(-1) == 'B') {
        segs[2] = s;
      }
      if(s.slice(-1) == 'E') {
        segs[3] = s;
      }
      if(s.slice(-1) == 'A') {
        segs[4] = s;
      }
    });
    if(!segs[0]) {
      segs[0] = "-F";
    }
    if(!segs[1]) {
      segs[1] = "-L";
    }
    if(!segs[2]) {
      segs[2] = "P-B";
    }
    if(!segs[3]) {
      segs[3] = "''E";
    }
    if(!segs[4]) {
      segs[4] = "'n'A";
    }
    
    segs.map(function(s, i) {
      switch(s.slice(-1)) {
        
        case 'F':
          var inputlistArray = parseRange(s.slice(0,-1), inputlists.length, inputlists); 
          inputlistArray.map(function(fl, i) {
            fs.readFileSync(inputlists[fl-1], 'utf8').split('\n').map(function(fline) {
              f.push(fline);
            }, this);
          }, this);
        break;
          
        case 'L':
          var lineArray = parseRange(s.slice(0,-1), f.length, f);
          lineArray.map(function(line, i) {
            l.push(f[line-1]);
          }, this);
        break;
          
        case 'B':
          b = l.map(function(filename, i) {
            var name = [];
            var baseArray = [];
            var dirname = path.dirname(filename);
            var basename = path.basename(filename);
            var bases = basename.split('.');
            
            if(s.slice(0, 1) == 'P'){
              baseArray = parseRange(s.slice(1,-1), bases.length, bases);
            } else {
              baseArray = parseRange(s.slice(0,-1), bases.length, bases);
            }
            baseArray.map(function(base, i) {
              name.push(bases[base-1]);
            }, this);
            return s.slice(0, 1) == 'P' ? path.join(dirname, name.join('.')) : name.join('.');
          }, this);
        break;
          
        case 'E':
          e = b.map(function(filename, i) {
            var extensionString = s.replace(/['"]+/g, '').slice(0,-1);
            if(extensionString.substr(0,1) == '-') {
              var basen = path.basename(filename);
              var dirn = path.dirname(filename);
              return dirn + "/" + extensionString.slice(1) + basen;
            } else {
              return filename + extensionString;
            }
          });
        break;
          
        case 'A':
          var arrangeString = s.replace(/['"]+/g, '').slice(0,-1);
          if(arrangeString == 'c') {
            a = e.join(',');
          } else if(arrangeString == 's') {
            a = e.join(' ');
          } else if(arrangeString == 'a') {
            a = e;
          } else if(arrangeString == 'n') {
            a = e.join('');
          } else if(arrangeString == 'l') {
            tool.looping = true;
            a = e.join('^LOOP^');
          } else {
            a = e.map(function(filename, i){
              return arrangeString+' '+filename;
            }).join(' ');
          }
        break;
 
      }
    }, this);
    return a;
  },
  
  parseRange: function(s, length, arr) {
    var r = [];    
    if(s.indexOf('/') > -1) {
      //parse regex range
      var regex = new RegExp(s.slice(1,-1));
      arr.map(function(string, i) {
        if(string.search(regex) > -1) {
          r.push(i+1);
        };
      }, this);
      return r;
    } else {
      //parse numeric range
      var a = s.split(',');
      a.map(function(ss, i) {
        if(ss.indexOf('-') > -1) {
          b = ss.split('-');
          if(b[0]=="" && b[1]==""){b[0] = 1; b[1] = length;}
          else if(b[1]==""){b[1] = length;}
          else if(b[0]==""){b[0] = 1;}
          else if(b.length>2 || Number(b[0]) > Number(b[1])){
            console.log("illegal range.")
            return;
          }
          for (var i = Number(b[0]); i <= Number(b[1]); i++) {
            r.push(i);
          }
        } else {
          r.push(Number(ss));
        }
      }, this);
      r.sort(function(x,y){return x-y});
      return _.uniq(r);
    }
  },

};

module.exports = CodeParse;
