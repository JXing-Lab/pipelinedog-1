var fs = require('fs');
var path = require('path');
var _ = require('lodash');

var Util = require('./util');
var FileOperation = require('./fileOperation');
var Police = require('./police');

var CodeParse = {
  initCode: function () {
    return `{
  "name": "New Step",
  "description": "A new step you just created",
  "invoke": "",
  "inputlists": [
    
  ],
  "options": [
    
  ],
  "input_option": "",
  "output_option": "",
  "log_option": "",
  "label_option": "",
  "output_files": [

  ]
}`;
  },

  syncEditorToState: function (app) {
    var tool = Util.filterByProperty(app.state.tools, "id", app.state.currentTool);
    var codeobj = {};
    try {
      codeobj = JSON.parse(tool.code);
    } catch (e) {
      console.log('JSON not valid.');
      tool.valid = false;
      app.setState(app.state);
      return;
    }
    tool.valid = true;
    tool.codeobj = codeobj;
    tool.name = codeobj.name;
    tool.description = codeobj.description;
    app.setState(app.state);
  },

  syncStateToEditor: function (app) {
    var tool = Util.filterByProperty(app.state.tools, "id", app.state.currentTool);
    tool.code = JSON.stringify(tool.codeobj, null, "  ");
  },

  generateCommand: function (app) {
    //combine each tool's command to generate a pipeline
    //parse every tool
    var originalTool = app.state.currentTool;
    for (var i = 0; i <= app.state.lastId; i++) {
      app.state.currentTool = i;
      if (!Police.checkToolDefinition(app)) {
        return false;
      }
      this.parseToolCommand(app);
      FileOperation.newParse(app);
    }
    app.state.currentTool = originalTool;

    app.state.command = "#!/usr/bin/bash";
    app.state.command += "\n#This code is generated by PipelineDog.\n";
    app.state.command += "cd " + app.state.workDir + "\n";
    app.state.tools.map(function (level, i) {
      level.map(function (tool, i) {
        app.state.command += "\n" + tool.parsedCommand;
      }, this);
      app.state.command += "\nwait\n";
    });

    return true;
  },

  parseToolCommand: function (app) {
    //replace placeholders and generate command for each tool

    //if these symbols are changed, the police class need to change accordingly.
    var scope = /[\{\}]/;
    var segment = '|';

    var tool = Util.filterByProperty(app.state.tools, "id", app.state.currentTool);

    this.convertExpressions(app, scope, segment);
    if (!tool.looping) {
      //if the tool is not looping    
      tool.parsedOptions = tool.codeobj.options.map(function (s, i) {
        //replace placeholders with the translated expressions
        var a = s.split(scope);
        for (var i = 1; i < a.length - 1; i += 2) {
          if (a[i] == "INPUT") {
            a[i] = tool.expressions[0];
          }
          if (a[i] == "OUTPUT") {
            a[i] = tool.expressions[1];
          }
          if (a[i] == "LABEL") {
            a[i] = tool.expressions[2];
          }
          if (a[i] == "LOG") {
            a[i] = tool.expressions[3];
          }
        }
        return a.join('');
      }, this);
      tool.parsedCommand = tool.codeobj.invoke + " " + tool.parsedOptions.join(" ") + "&";
    } else {
      //if the tool is looping
      tool.parsedCommand = "";
      var inputLoopArray = [],
          outputLoopArray = [],
          labelLoopArray = [],
          logLoopArray = [];
      if (tool.expressions[0]) inputLoopArray = tool.expressions[0].split('^LOOP^');
      if (tool.expressions[1]) outputLoopArray = tool.expressions[1].split('^LOOP^');
      if (tool.expressions[2]) labelLoopArray = tool.expressions[2].split('^LOOP^');
      if (tool.expressions[3]) logLoopArray = tool.expressions[3].split('^LOOP^');
      inputLoopArray.map(function (fn, i, a) {
        var index = i;
        var filename = fn;
        var array = a;
        tool.parsedOptions = tool.codeobj.options.map(function (s, i) {
          //overwrite the placeholder replacement to assign one filename to parsed options a time
          var a = s.split(scope);
          for (var i = 1; i < a.length - 1; i += 2) {
            if (a[i] == "INPUT") {
              a[i] = inputLoopArray[index];
            }
            if (a[i] == "OUTPUT") {
              a[i] = outputLoopArray[index];
            }
            if (a[i] == "LABEL") {
              a[i] = labelLoopArray[index];
            }
            if (a[i] == "LOG") {
              a[i] = logLoopArray[index];
            }
          }
          return a.join('');
        }, this);
        if (index !== array.length - 1) {
          tool.parsedCommand += tool.codeobj.invoke + " " + tool.parsedOptions.join(" ") + "&\n";
        } else {
          tool.parsedCommand += tool.codeobj.invoke + " " + tool.parsedOptions.join(" ") + "&";
        }

        //process looping for output files
        if (tool.expressions[4]) {
          tool.expressions[4] = tool.expressions[4].map(function (of, i) {
            if (of.indexOf('^LOOP^') == -1) {
              return of;
            } else {
              return of.split('^LOOP^');
            }
          }, this);
          tool.output_files = _.flattenDeep(tool.expressions[4]);
        }
      }, this);
    }
  },

  convertExpressions: function (app, scope, segment) {
    //recognize LEASH expressions, also update output_files info
    var tool = Util.filterByProperty(app.state.tools, "id", app.state.currentTool);
    tool.expressions = [tool.codeobj.input_option, tool.codeobj.output_option, tool.codeobj.label_option, tool.codeobj.log_option, tool.codeobj.output_files];

    tool.expressions = tool.expressions.map(function (e, i) {
      //convert objects to standard LEASH
      if (typeof e == "object") {
        //Long(object) format
        var pseudoString = "{";
        if (e.file) pseudoString += `${ e.file }F|`;
        if (e.line) pseudoString += `${ e.line }L|`;
        if (e.base) pseudoString += `${ e.base }B|`;
        if (e.extension) pseudoString += `${ e.extension }E|`;
        if (e.arrangement) pseudoString += `${ e.arrangement }A|`;
        pseudoString = pseudoString.slice(0, -1);
        pseudoString += "}";
        return i != 4 ? pseudoString : [pseudoString];
      } else {
        //Short(string or array) format
        return e;
      }
    }.bind(this));

    for (var j = 0; j < 4; j++) {
      //translate each LEASH expressions
      if (tool.expressions[j] && typeof tool.expressions[j] != "object") {
        var a = tool.expressions[j].split(scope);
        for (var i = 1; i < a.length - 1; i += 2) {
          a[i] = this.parseLEASH(a[i], tool, segment);
        }
        tool.expressions[j] = a.join("");
      }
    }

    var outfilesArray = []; //process output_files array
    tool.expressions[4].map(function (s) {
      var a = s.split(scope);
      if (a.length >= 3) {
        for (var i = 1; i < a.length - 1; i += 2) {
          outfilesArray.push(this.parseLEASH(a[i], tool, segment));
        }
      } else {
        outfilesArray.push(s);
      }
    }.bind(this));
    tool.expressions[4] = _.flattenDeep(outfilesArray);
  },

  parseLEASH: function (expression, tool, segment) {
    //parse LEASH expression and process inputlists
    var inputlists = tool.codeobj.inputlists;
    var segs = [];
    var f = [],
        l = [],
        b = [],
        e = [],
        a = "";

    expression.split(segment).map(function (s, i) {
      if (s.slice(-1) == 'F') {
        segs[0] = s;
      }
      if (s.slice(-1) == 'L') {
        segs[1] = s;
      }
      if (s.slice(-1) == 'B') {
        segs[2] = s;
      }
      if (s.slice(-1) == 'E') {
        segs[3] = s;
      }
      if (s.slice(-1) == 'A') {
        segs[4] = s;
      }
    });
    if (!segs[0]) {
      segs[0] = "-F";
    }
    if (!segs[1]) {
      segs[1] = "-L";
    }
    if (!segs[2]) {
      segs[2] = "P-B";
    }
    if (!segs[3]) {
      segs[3] = "''E";
    }
    if (!segs[4]) {
      segs[4] = "'n'A";
    }

    segs.map(function (s, i) {
      switch (s.slice(-1)) {

        case 'F':
          var inputlistArray = this.parseRange(s.slice(0, -1), inputlists.length, inputlists);
          inputlistArray.map(function (fl, i) {
            fs.readFileSync(inputlists[fl - 1], 'utf8').split('\n').map(function (fline) {
              f.push(fline);
            }, this);
          }, this);
          break;

        case 'L':
          var lineArray = this.parseRange(s.slice(0, -1), f.length, f);
          lineArray.map(function (line, i) {
            l.push(f[line - 1]);
          }, this);
          break;

        case 'B':
          b = l.map(function (filename, i) {
            var name = [];
            var baseArray = [];
            var dirname = path.dirname(filename);
            var basename = path.basename(filename);
            var bases = basename.split('.');

            if (s.slice(0, 1) == 'P') {
              baseArray = this.parseRange(s.slice(1, -1), bases.length, bases);
            } else {
              baseArray = this.parseRange(s.slice(0, -1), bases.length, bases);
            }
            baseArray.map(function (base, i) {
              name.push(bases[base - 1]);
            }, this);
            return s.slice(0, 1) == 'P' ? path.join(dirname, name.join('.')) : name.join('.');
          }, this);
          break;

        case 'E':
          var r = '';
          e = b.map(function (filename, i) {
            var arr = s.slice(0, -1).split("'");
            for (var i = 0; i < arr.length - 1; i += 2) {
              var extensionString = arr[i + 1];
              if (arr[i] == 'PRE') {
                var basen = path.basename(filename);
                var dirn = path.dirname(filename);
                if (dirn == ".") {
                  filename = extensionString + basen;
                } else {
                  filename = dirn + "/" + extensionString + basen;
                }
              } else {
                filename = filename + extensionString;
              }
            }

            return filename;
          });
          break;

        case 'A':
          var arrangeString = s.replace(/['"]+/g, '').slice(0, -1);
          if (arrangeString == 'c') {
            a = e.join(',');
          } else if (arrangeString == 's') {
            a = e.join(' ');
          } else if (arrangeString == 'a') {
            a = e;
          } else if (arrangeString == 'n') {
            a = e.join('');
          } else if (arrangeString == 'l') {
            tool.looping = true;
            a = e.join('^LOOP^');
          } else {
            a = e.map(function (filename, i) {
              return arrangeString + ' ' + filename;
            }).join(' ');
          }
          break;

      }
    }, this);
    return a;
  },

  parseRange: function (s, length, arr) {
    var r = [];
    if (s.indexOf('/') > -1) {
      //parse regex range
      var regex = new RegExp(s.slice(1, -1));
      arr.map(function (string, i) {
        if (string.search(regex) > -1) {
          r.push(i + 1);
        };
      }, this);
      return r;
    } else {
      //parse numeric range
      var a = s.split(',');
      a.map(function (ss, i) {
        if (ss.indexOf('-') > -1) {
          b = ss.split('-');
          if (b[0] == "" && b[1] == "") {
            b[0] = 1;b[1] = length;
          } else if (b[1] == "") {
            b[1] = length;
          } else if (b[0] == "") {
            b[0] = 1;
          } else if (b.length > 2 || Number(b[0]) > Number(b[1])) {
            console.log("illegal range.");
            return;
          }
          for (var i = Number(b[0]); i <= Number(b[1]); i++) {
            r.push(i);
          }
        } else {
          r.push(Number(ss));
        }
      }, this);
      r.sort(function (x, y) {
        return x - y;
      });
      return _.uniq(r);
    }
  }

};

module.exports = CodeParse;