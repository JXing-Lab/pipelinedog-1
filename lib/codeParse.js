var fs = require('fs');
var path = require('path');
var Util = require('./util');
var _ = require('lodash');

var CodeParse = {
  initCode: function () {
    return `{
  "name": "New Step",
  "description": "A new step you just created",
  "invoke": "",
  "filelists": [
    
  ],
  "options": [
    
  ],
  "input_option": "",
  "output_option": "",
  "label_option": "",
  "output_files": [

  ]
}`;
  },

  syncEditorToState: function (app) {
    var tool = Util.filterByProperty(app.state.tools, "id", app.state.currentTool);
    var codeobj = {};
    try {
      codeobj = JSON.parse(tool.code);
    } catch (e) {
      console.log('JSON not valid.');
      tool.valid = false;
      app.setState(app.state);
      return;
    }
    tool.valid = true;
    tool.codeobj = codeobj;
    tool.name = codeobj.name;
    tool.description = codeobj.description;
    app.setState(app.state);
  },

  syncStateToEditor: function (app) {
    var tool = Util.filterByProperty(app.state.tools, "id", app.state.currentTool);
    tool.code = JSON.stringify(tool.codeobj, null, "  ");
  },

  generateCommnad: function (app) {
    //combine each tool's command to generate a pipeline
    var command = "#!/usr/bin/bash";
    command += "\n#This code is generated by PipelineDog.";
    app.tools.map(function (hierarchy, i) {
      hierarchy.map(function (tool, i) {
        command += "\n" + tool.parsedCommand + "&";
      }.this);
      command += "\nwait";
    });
  },

  parseToolCommand: function (app) {
    //generate command for each tool and create predicted filelist
    var tool = Util.filterByProperty(app.state.tools, "id", app.state.currentTool);
    this.convertOptionString(app);
    tool.parsedCommand = tool.codeobj.invoke + " " + tool.parsedOptions.join(" ");
    tool.code = tool.parsedCommand;
  },

  convertOptionString: function (app) {
    //recognize LEASH expression and replace it
    var codeobj = Util.filterByProperty(app.state.tools, "id", app.state.currentTool).codeobj;
    var scope = '%';
    var segment = ':';
    var strings = [codeobj.input_option, codeobj.output_option, codeobj.label_option];

    strings = strings.map(function (s, i) {
      //translate each LEASH expressions
      if (!s) {
        return;
      }
      var a = s.split(scope);
      for (var i = 1; i < a.length - 1; i += 2) {
        a[i] = this.parseLEASH(a[i], codeobj, segment, fs, this.parseRange);
      }
      return a.join("");
    }, this);

    var outfilesArray = []; //process output_files array
    codeobj.output_files.map(function (s) {
      var a = s.split(scope);
      for (var i = 1; i < a.length - 1; i += 2) {
        outfilesArray.push(this.parseLEASH(a[i], codeobj, segment, fs, this.parseRange));
      }
    }, this);
    Util.filterByProperty(app.state.tools, "id", app.state.currentTool).output_files = _.flattenDeep(outfilesArray);

    Util.filterByProperty(app.state.tools, "id", app.state.currentTool).parsedOptions = codeobj.options.map(function (s, i) {
      //replace placeholders with the translated expressions
      var a = s.split(scope);
      for (var i = 1; i < a.length - 1; i += 2) {
        if (a[i] == "INPUT") {
          a[i] = strings[0];
        }
        if (a[i] == "OUTPUT") {
          a[i] = strings[1];
        }
        if (a[i] == "LABEL") {
          a[i] = strings[2];
        }
      }
      return a.join('');
    }, this);
  },

  parseLEASH: function (expression, codeobj, segment, fs, parseRange) {
    //parse LEASH expression and process filelists
    var filelists = codeobj.filelists;
    var segs = expression.split(segment);
    var filelines = [];
    var f = [],
        l = [],
        b = [],
        e = [],
        a = "";

    segs.map(function (s, i) {
      switch (s.slice(-1)) {

        case 'F':
          var filelistArray = parseRange(s.slice(0, -1), filelists.length);
          filelistArray.map(function (fl, i) {
            fs.readFileSync(filelists[fl - 1], 'utf8').split('\n').map(function (fline) {
              f.push(fline);
            }, this);
          }, this);
          break;

        case 'L':
          var lineArray = parseRange(s.slice(0, -1), f.length);
          lineArray.map(function (line, i) {
            l.push(f[line - 1]);
          }, this);
          break;

        case 'B':
          b = l.map(function (filename, i) {
            var name = [];
            var baseArray = [];
            var dirname = path.dirname(filename);
            var basename = path.basename(filename);
            var bases = basename.split('.');

            if (s.slice(0, 1) == 'P') {
              baseArray = parseRange(s.slice(1, -1), bases.length);
            } else {
              baseArray = parseRange(s.slice(0, -1), bases.length);
            }
            baseArray.map(function (base, i) {
              name.push(bases[base - 1]);
            }, this);
            return s.slice(0, 1) == 'P' ? path.join(dirname, name.join('.')) : name.join('.');
          }, this);
          break;

        case 'E':
          e = b.map(function (filename, i) {
            var extensionString = s.replace(/['"]+/g, '').slice(0, -1);
            if (extensionString.substr(0, 1) == '-') {
              return extensionString.slice(1) + filename;
            } else {
              return filename + extensionString;
            }
          });
          break;

        case 'A':
          var arrangeString = s.replace(/['"]+/g, '').slice(0, -1);
          if (arrangeString == 'c') {
            a = e.join(',');
          } else if (arrangeString == 's') {
            a = e.join(' ');
          } else if (arrangeString == 'l') {
            codeobj.looping = true;
            a = e;
          } else {
            a = e.map(function (filename, i) {
              return arrangeString + ' ' + filename;
            }).join(' ');
          }
          break;

        default:
          console.log("illegal LEASE expression.");
      }
    }, this);
    return a === "" ? e : a;
  },

  parseRange: function (s, length) {
    var a = s.split(',');
    var r = [];
    a.map(function (ss, i) {
      if (ss.indexOf('-') > -1) {
        b = ss.split('-');
        if (b[0] == "" && b[1] == "") {
          b[0] = 1;b[1] = length;
        } else if (b[1] == "") {
          b[1] = length;
        } else if (b[0] == "") {
          b[0] = 1;
        } else if (b.length > 2 || Number(b[0]) > Number(b[1])) {
          console.log("illegal range.");
          return;
        }
        for (var i = Number(b[0]); i <= Number(b[1]); i++) {
          r.push(i);
        }
      } else {
        r.push(Number(ss));
      }
    }, this);
    r.sort(function (x, y) {
      return x - y;
    });
    return _.uniq(r);
  }

};

module.exports = CodeParse;